// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using Microsoft.CSharp;
using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Reflection;
using System.Text;
using SunflowSharp.Systems;


namespace SunflowSharp.Systems
{
	/**
	 * This class represents a list of plugins which implement a certain interface
	 * or extend a certain class. Many plugins may be registered and created at a
	 * later time by recalling their unique name only.
	 *
	 * @param <T> Default constructible type or interface all plugins will derive
	 * from or implement
	 */
	public class Plugins<T> {
		private Dictionary<string, Type> pluginClasses;
		private Type baseClass;
		
		/**
		 * Create an empty plugin list. You must specify <code>T.class</code> as
		 * an argument.
		 *
		 * @param baseClass
		 */
		public Plugins(Type baseClass) {
			pluginClasses = new Dictionary<string, Type>();
			this.baseClass = baseClass;
		}
		
		/**
		 * Create an object from the specified type name. If this type name is
		 * unknown or invalid, <code>null</code> is returned.
		 *
		 * @param name plugin type name
		 * @return an instance of the specified plugin type, or <code>null</code>
		 * if not found or invalid
		 */
		public T createObject(string name) {
			Type c;
			if (name == null || name.Equals ("none"))
				return default(T);
			if (pluginClasses.ContainsKey (name)) {
				c = (Type)pluginClasses [name];
			} 
			else 
			{
				// don't print an error, this will be handled by the caller
				return default(T);
			}
			try {
				return (T)Activator.CreateInstance(c);
			} catch (MissingMethodException e) {
				UI.printError(UI.Module.API, "Cannot create object of type \"{0}\" - {1}", name, e.Message);
				return default(T);
			}
		}
		
		/**
		 * Check this plugin list for the presence of the specified type name
		 *
		 * @param name plugin type name
		 * @return <code>true</code> if this name has been registered,
		 * <code>false</code> otherwise
		 */
		public bool hasType(string name) {
			return pluginClasses.ContainsKey(name);
		}
		
		/**
		 * Generate a unique plugin type name which has not yet been registered.
		 * This is meant to be used when the actual type name is not crucial, but
		 * succesfully registration is.
		 *
		 * @param prefix a prefix to be used in generating the unique name
		 * @return a unique plugin type name not yet in use
		 */
		public string generateUniqueName(string prefix) {
			string type;
			for (int i = 1; hasType(type = string.Format("{0}_{1}", prefix, i)); i++) {
			}
			return type;
		}
		
		/**
		 * Define a new plugin type from java source code. The code string contains
		 * import declarations and a class body only. The implemented type is
		 * implicitly the one of the plugin list being registered against.If the
		 * plugin type name was previously associated with a different class, it
		 * will be overriden. This allows the behavior core classes to be modified
		 * at runtime.
		 *
		 * @param name plugin type name
		 * @param sourceCode Java source code definition for the plugin
		 * @return <code>true</code> if the code compiled and registered
		 * successfully, <code>false</code> otherwise
		 */

		public bool registerPlugin(string name, string sourceCode) {

			CSharpCodeProvider provider = new CSharpCodeProvider();
			CompilerParameters  compilerParameters = new CompilerParameters();

			// generate an in memory ddl;
			compilerParameters.GenerateInMemory = true;
			compilerParameters.GenerateExecutable = false;
			compilerParameters.ReferencedAssemblies.Add("SunflowSharp.dll");
			compilerParameters.TreatWarningsAsErrors = false;
			compilerParameters.CompilerOptions = "/optimize";

			// System.dll is not always needed but extends the amount of c# that can be used.
			compilerParameters.ReferencedAssemblies.Add( "System.dll" );
			

			// Set the level at which the compiler  
			// should start displaying warnings.
			compilerParameters.WarningLevel = 1;


			CompilerResults results = provider.CompileAssemblyFromSource(compilerParameters, sourceCode);

			if (results.Errors.HasErrors)
			{
				StringBuilder sb = new StringBuilder();
				
				foreach (CompilerError error in results.Errors)
				{
					sb.AppendLine(String.Format("Error ({0}): {1}", error.ErrorNumber, error.ErrorText));
				}
				
				throw new InvalidOperationException(sb.ToString());
			}

			Type compiledType = null;


			foreach (Type tmp in results.CompiledAssembly.GetTypes()) 
			{
				foreach (Type interfaceType in tmp.GetInterfaces()) 
				{
					if (interfaceType == typeof(T))
						compiledType = tmp;
				}
			}

			if (compiledType != null)
				return registerPlugin(name, compiledType);

			throw new InvalidOperationException(string.Format("Code for {0} does not inherit from {1}", name, typeof(T)));

		}

		
		/**
		 * Define a new plugin type from an existing class. This checks to make sure
		 * the provided class is default constructible (ie: has a constructor with
		 * no parameters). If the plugin type name was previously associated with a
		 * different class, it will be overriden. This allows the behavior core
		 * classes to be modified at runtime.
		 *
		 * @param name plugin type name
		 * @param pluginClass class object for the plugin class
		 * @return <code>true</code> if the plugin registered successfully,
		 * <code>false</code> otherwise
		 */
		public bool registerPlugin(string name, Type pluginClass) {
			// check that the given class is compatible with the base class
				if (pluginClass.GetConstructor(Type.EmptyTypes) == null) {
				    UI.printError(UI.Module.API, "Plugin \"{0}\" could not be declared - default constructor was not found", name);
					return false;
				}
			if (pluginClasses.ContainsKey(name))
				UI.printWarning(UI.Module.API, "Plugin \"{0}\" was already defined - overwriting previous definition", name);
			pluginClasses.Add(name, pluginClass);
			return true;
		}
	}
}

