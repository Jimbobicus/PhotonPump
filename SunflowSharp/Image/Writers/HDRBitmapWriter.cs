// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System.IO;

namespace SunflowSharp.Image.Writers
{
	public class HDRBitmapWriter : BitmapWriter {
		private string filename;
		private int width, height;
		private int[] data;

		private const int MINELEN = 8;	    /* minimum scanline length for encoding */
		private const int MAXELEN = 0x7fff;	/* maximum scanline length for encoding */
		private const int MINRUN = 4;		/* minimum run length */
		
		public override void configure(string option, string value) {
		}
		
		public override void openFile(string filename) {
			this.filename = filename;
		}
		
		public override void writeHeader(int width, int height, int tileSize) {
			this.width = width;
			this.height = height;
			data = new int[width * height];
		}
		
		public override void writeTile(int x, int y, int w, int h, Color[] color, float[] alpha) {
			int[] tileData = ColorEncoder.encodeRGBE(color);
			for (int j = 0, index = 0, pixel = x + y * width; j < h; j++, pixel += width - w)
				for (int i = 0; i < w; i++, index++, pixel++)
					data[pixel] = tileData[index];
		}
		
		public override void closeFile() {


			FileStream f = new FileStream(filename, FileMode.Create);
			byte[] buffer = System.Text.ASCIIEncoding.ASCII.GetBytes("#?RADIANCE\n");
			f.Write(buffer, 0, buffer.Length);
			buffer = System.Text.ASCIIEncoding.ASCII.GetBytes("FORMAT=32-bit_rle_rgbe\n\n");
			f.Write(buffer, 0, buffer.Length);
			buffer = System.Text.ASCIIEncoding.ASCII.GetBytes("-Y " + height + " +X " + width + "\n");
			f.Write(buffer, 0, buffer.Length);
			for (int y = 0; y  < height; y++)
			{
				WriteRLEScanLine(f, y * width);
			}
			f.Close();

		}

		private void WriteRLEScanLine(FileStream f, int scanlineOffset) {

			int len, c2;
			int j, cnt, beg;

			uint[] MASK = {0xFF000000, 0x00FF0000, 0x0000FF00, 0x000000FF};


			len = width;

			f.WriteByte(2);
			f.WriteByte(2);
			f.WriteByte((byte)(width >> 8));
			f.WriteByte((byte)(width & 255));

			cnt = 0;

			for (int i = 0; i < 4; i++) {  // each component is encoded seperately
				for (j = 0; j < len; j += cnt) {	// find next run 

					for (beg = j; beg < len; beg += cnt) {

						for (cnt = 1; cnt < 127
						              && beg+cnt < len 
						     		  && (data[scanlineOffset+beg+cnt] & MASK[i]) == (data[scanlineOffset+beg] & MASK[i]) ; cnt++) {
							;  // everything done in for statement
						}
					    if (cnt >= MINRUN) {
							break;	// the run is long enough
						}
					}
					if (beg-j > 1 && beg-j < MINRUN) {
						c2 = j+1;
						while ((data[scanlineOffset + (c2++)] & MASK[i]) == (data[scanlineOffset + j] & MASK[i]))
						if (c2 == beg) {	/* short run */
							f.WriteByte((byte)(128+beg-j));
							f.WriteByte((byte)(data[scanlineOffset + j] >> ((3 - i) * 8)));
							j = beg;
							break;
						}
					}
					while (j < beg) {		/* write out non-run */
						if ((c2 = beg-j) > 128) c2 = 128;
						f.WriteByte((byte)c2);
						while (c2-- > 0)
							f.WriteByte((byte)(data[scanlineOffset + (j++)] >> ((3 - i) * 8)));
					}
					if (cnt >= MINRUN) {		/* write out run */
						f.WriteByte((byte)(128+cnt));
						f.WriteByte((byte)(data[scanlineOffset + beg] >> ((3 - i) * 8)));
					} else
						cnt = 0;
				}
			}

		}
	}
}

