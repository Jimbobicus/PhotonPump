// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System.IO;
namespace SunflowSharp.Image.Writers
{
	public class TGABitmapWriter : BitmapWriter {
		private string filename;
		private int width, height;
		private byte[] data;
		
		public override void configure(string option, string value) {
		}
		
		public override void openFile(string filename) {
			this.filename = filename;
		}
		
		public override void writeHeader(int width, int height, int tileSize) {
			this.width = width;
			this.height = height;
			data = new byte[width * height * 4]; // RGBA8
		}
		
		public override void writeTile(int x, int y, int w, int h, Color[] color, float[] alpha) {
			color = ColorEncoder.unlinearize(color); // gamma correction
			byte[] tileData = ColorEncoder.quantizeRGBA8(color, alpha);
			for (int j = 0, index = 0; j < h; j++) {
				int imageIndex = 4 * (x + (height - 1 - (y + j)) * width);
				for (int i = 0; i < w; i++, index += 4, imageIndex += 4) {
					// swap bytes around so buffer is in native BGRA order
					data[imageIndex + 0] = tileData[index + 2];
					data[imageIndex + 1] = tileData[index + 1];
					data[imageIndex + 2] = tileData[index + 0];
					data[imageIndex + 3] = tileData[index + 3];
				}
			}
		}
		
		public override void closeFile() {

			FileStream f = new FileStream(filename, FileMode.OpenOrCreate);
			// no id, no colormap, uncompressed 3bpp RGB
			byte[] tgaHeader = { 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
			f.Write(tgaHeader, 0, tgaHeader.Length);
			// then the size info
			f.WriteByte((byte)(width & 0xFF));
			f.WriteByte((byte)((width >> 8) & 0xFF));
			f.WriteByte((byte)(height & 0xFF));
			f.WriteByte((byte)((height >> 8) & 0xFF));
			// bitsperpixel and filler
			f.WriteByte(32);
			f.WriteByte(0);
			// image data
			int imageIndex = 0;
			for (int y = 0; y < height; y++)
			{
				for (int x = 0; x < width; x++, imageIndex+=4)
				{
					f.WriteByte(data[imageIndex + 0]);
					f.WriteByte(data[imageIndex + 1]);
					f.WriteByte(data[imageIndex + 2]);
					f.WriteByte(data[imageIndex + 3]);
				}
			}
			f.Close();
		}
	}
}

