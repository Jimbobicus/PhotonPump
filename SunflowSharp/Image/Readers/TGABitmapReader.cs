// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using System.IO;
using SunflowSharp.Image.Formats;
 
namespace SunflowSharp.Image.Readers
{
	public class TGABitmapReader : BitmapReader 
	{
		private static int[] CHANNEL_INDEX = { 2, 1, 0, 3 };
		
		public override Bitmap load(String filename, bool isLinear)  {
			FileStream f = new FileStream(filename, FileMode.Open);
			byte[] read = new byte[4];
			
			// read header
			int idsize = f.ReadByte();
			int cmaptype = f.ReadByte(); // cmap byte (unsupported)
			if (cmaptype != 0)
				throw new BitmapFormatException(String.Format("Colormapping (type: {0}) is unsupported", cmaptype));
			int datatype = f.ReadByte();
			
			// colormap info (5 bytes ignored)
			f.ReadByte();
			f.ReadByte();
			f.ReadByte();
			f.ReadByte();
			f.ReadByte();
			
			f.ReadByte(); // xstart, 16 bits (ignored)
			f.ReadByte();
			f.ReadByte(); // ystart, 16 bits (ignored)
			f.ReadByte();
			
			// read resolution
			int width = f.ReadByte();
			width |= f.ReadByte() << 8;
			int height = f.ReadByte();
			height |= f.ReadByte() << 8;
			
			int bits = f.ReadByte();
			int bpp = bits / 8;
			
			int imgdscr = f.ReadByte();
			
			// skip image ID if present
			if (idsize != 0)
				f.Seek(idsize, SeekOrigin.Current);
			
			// allocate byte buffer to hold the image
			byte[] pixels = new byte[width * height * bpp];
			if (datatype == 2 || datatype == 3) {
				if (bpp != 1 && bpp != 3 && bpp != 4)
					throw new BitmapFormatException(String.Format("Invalid bit depth in uncompressed TGA: {0}", bits));
				// uncompressed image
				for (int ptr = 0; ptr < pixels.Length; ptr += bpp) {
					// read bytes
					f.Read(read, 0, bpp);
					for (int i = 0; i < bpp; i++)
						pixels[ptr + CHANNEL_INDEX[i]] = read[i];
				}
			} else if (datatype == 10) {
				if (bpp != 3 && bpp != 4)
					throw new BitmapFormatException(String.Format("Invalid bit depth in run-length encoded TGA: {0}", bits));
				// RLE encoded image
				for (int ptr = 0; ptr < pixels.Length;) {
					int rle = f.ReadByte();
					int num = 1 + (rle & 0x7F);
					if ((rle & 0x80) != 0) {
						// rle packet - decode length and copy pixel
						f.Read(read, 0, bpp);
						for (int j = 0; j < num; j++) {
							for (int i = 0; i < bpp; i++)
								pixels[ptr + CHANNEL_INDEX[i]] = read[i];
							ptr += bpp;
						}
					} else {
						// raw packet - decode length and read pixels
						for (int j = 0; j < num; j++) {
							f.Read(read, 0, bpp);
							for (int i = 0; i < bpp; i++)
								pixels[ptr + CHANNEL_INDEX[i]] = read[i];
							ptr += bpp;
						}
					}
				}
			} else
				throw new BitmapFormatException(String.Format("Unsupported TGA image type: {0}", datatype));
			
			if (!isLinear) {
				// apply reverse correction
				for (int ptr = 0; ptr < pixels.Length; ptr += bpp) {
					for (int i = 0; i < 3 && i < bpp; i++)
						pixels[ptr + i] = Color.NATIVE_SPACE.rgbToLinear(pixels[ptr + i]);
				}
			}
			
			// should image be flipped in Y?
			if ((imgdscr & 32) == 32) {
				for (int y = 0, pix_ptr = 0; y < (height / 2); y++) {
					int bot_ptr = bpp * (height - y - 1) * width;
					for (int x = 0; x < width; x++) {
						for (int i = 0; i < bpp; i++) {
							byte t = pixels[pix_ptr + i];
							pixels[pix_ptr + i] = pixels[bot_ptr + i];
							pixels[bot_ptr + i] = t;
						}
						pix_ptr += bpp;
						bot_ptr += bpp;
					}
				}
				
			}
			f.Close();
			switch (bpp) {
			case 1:
				return new BitmapG8(width, height, pixels);
			case 3:
				return new BitmapRGB8(width, height, pixels);
			case 4:
				return new BitmapRGBA8(width, height, pixels);
			}
			throw new BitmapFormatException("Inconsistent code in TGA reader");
		}
	}
}

