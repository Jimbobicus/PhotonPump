// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;

using SunflowSharp.Maths;
using SunflowSharp.Image;

namespace SunflowSharp.Core.PhotonMap
{
	public class Photon
	{
		public float x, y, z;
		public short dir, normal;
		public int data, power, flags;
		
		public const int SPLIT_X = 0;
		public const int SPLIT_Y = 1;
		public const int SPLIT_Z = 2;
		public const int SPLIT_MASK = 3;
		
		public Photon(Point3 p, Vector3 n, Vector3 dir, Color power, Color diffuse)
		{
			x = p.x;
			y = p.y;
			z = p.z;
			this.dir = dir.encode();
			this.power = power.toRGBE();
			flags = 0;
			normal = n.encode();
			data = diffuse.toRGB();
		}

		public Photon(Point3 p, Vector3 dir, Color power)
		{
			x = p.x;
			y = p.y;
			z = p.z;
			this.dir = dir.encode();
			this.power = power.toRGBE();
			flags = 0;
		}

		public void setSplitAxis(int axis)
		{
			flags &= ~SPLIT_MASK;
			flags |= axis;
		}
		
		public float getCoord(int axis)
		{
			switch (axis)
			{
			case SPLIT_X:
				return x;
			case SPLIT_Y:
				return y;
			default:
				return z;
			}
		}
		
		public float getDist1(float px, float py, float pz)
		{
			switch (flags & SPLIT_MASK)
			{
			case SPLIT_X:
				return px - x;
			case SPLIT_Y:
				return py - y;
			default:
				return pz - z;
			}
		}
		
		public float getDist2(float px, float py, float pz)
		{
			float dx = x - px;
			float dy = y - py;
			float dz = z - pz;
			return (dx * dx) + (dy * dy) + (dz * dz);
		}

		public static Photon[] BalancePhotons (ref Photon[] unbalanced) {

			SortedList<Int64, Photon> balanced = new SortedList<Int64, Photon>();

			BalancePhotons(balanced, 1, 1, unbalanced.Length-1, 1, ref unbalanced);

			int index=0;

			foreach(KeyValuePair<Int64, Photon> photon in balanced) {
			
				unbalanced[index++] = photon.Value;
			
			}

			balanced = null;

			return unbalanced;
		}

		private static void BalancePhotons (SortedList<Int64, Photon> balanced, int index, int start, int end, int level, ref Photon[] unbalanced) {

//			Console.WriteLine("index {0},  start {1},  end {2},  level {3}",index,  start,  end,  level);

			switch (level % 3) {
				case Photon.SPLIT_X:
					Array.Sort(unbalanced, start, end - start + 1, new XAxisCompare()); 
					break;
				case Photon.SPLIT_Y:
					Array.Sort(unbalanced, start, end - start + 1, new YAxisCompare()); 
					break;
				case Photon.SPLIT_Z:
					Array.Sort(unbalanced, start, end - start + 1, new ZAxisCompare()); 
					break;
				default:
					break;
			}

			int median = start + ((end - start) / 2);
			
			balanced[index] = unbalanced[median];

			if (median > start)
			{
				if (start < (median - 1))
				{
					BalancePhotons(balanced, index * 2, start, median-1, level + 1, ref unbalanced);
				}
				else
				{
					balanced[index * 2] = unbalanced[start];
				}
			}

			if (median < end)
			{
				if ((median + 1) < end)
				{
					BalancePhotons(balanced, index * 2 + 1, median+1, end, level + 1, ref unbalanced);
				}
				else
				{
					balanced[(index * 2) + 1 ] = unbalanced[end];
				}
			}


		}

		private class XAxisCompare : IComparer  {
			

			int IComparer.Compare( Object x, Object y )  {

				Photon px = (Photon)x;
				Photon py = (Photon)y;

				if (px.x == py.x) return 0;
				if (px.x < py.x) return -1;
				return 1;

			}
			
		}

		
		private class YAxisCompare : IComparer  {
			
	
			int IComparer.Compare( Object x, Object y )  {
				
				Photon px = (Photon)x;
				Photon py = (Photon)y;
				
				if (px.y == py.y) return 0;
				if (px.y < py.y) return -1;
				return 1;
				
			}
			
		}
	
		private class ZAxisCompare : IComparer  {
			
			// Calls CaseInsensitiveComparer.Compare with the parameters reversed.
			int IComparer.Compare( Object x, Object y )  {
				
				Photon px = (Photon)x;
				Photon py = (Photon)y;
				
				if (px.z == py.z) return 0;
				if (px.z < py.z) return -1;
				return 1;
				
			}
			
		}


	}
}

