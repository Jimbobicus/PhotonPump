
// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using System.IO;
using SunflowSharp.Image.Formats;


namespace SunflowSharp.Image.Readers
{
	public class IGIBitmapReader : BitmapReader {

		public override Bitmap load(string filename, bool isLinear) {

			FileStream stream = new FileStream(filename, FileMode.Open);
			// read header
			int magic = read32i(stream);
			int version = read32i(stream);
			stream.Seek(8, SeekOrigin.Current); // skip number of samples (double value)
			int width = read32i(stream);
			int height = read32i(stream);
			int superSample = read32i(stream); // super sample factor
			int compression = read32i(stream);
			int dataSize = read32i(stream);
			int colorSpace = read32i(stream);
			stream.Seek(5000, SeekOrigin.Current); // skip the rest of the header (unused for now)
			// error checking
			if (magic != 66613373)
				throw new BitmapFormatException("wrong magic: " + magic);
			if (version != 1)
				throw new BitmapFormatException("unsupported version: " + version);
			if (compression != 0)
				throw new BitmapFormatException("unsupported compression: " + compression);
			if (colorSpace != 0)
				throw new BitmapFormatException("unsupported color space: " + colorSpace);
			if (dataSize != (width * height * 12))
				throw new BitmapFormatException("invalid data block size: " + dataSize);
			if (width <= 0 || height <= 0)
				throw new BitmapFormatException("invalid image size: " + width + "x" + height);
			if (superSample <= 0)
				throw new BitmapFormatException("invalid super sample factor: " + superSample);
			if ((width % superSample) != 0 || (height % superSample) != 0)
				throw new BitmapFormatException("invalid image size: " + width + "x" + height);
			float[] xyz = new float[width * height * 3];
			for (int y = 0, i = 3 * (height - 1) * width; y < height; y++, i -= 6 * width) {
				for (int x = 0; x < width; x++, i += 3) {
					xyz[i + 0] = read32f(stream);
					xyz[i + 1] = read32f(stream);
					xyz[i + 2] = read32f(stream);
				}
			}
			stream.Close();
			if (superSample > 1) {
				// rescale image (basic box filtering)
				float[] rescaled = new float[xyz.Length / (superSample * superSample)];
				float inv = 1.0f / (superSample * superSample);
				for (int y = 0, i = 0; y < height; y += superSample) {
					for (int x = 0; x < width; x += superSample, i += 3) {
						float X = 0;
						float Y = 0;
						float Z = 0;
						for (int sy = 0; sy < superSample; sy++) {
							for (int sx = 0; sx < superSample; sx++) {
								int offset = 3 * ((x + sx + (y + sy) * width));
								X += xyz[offset + 0];
								Y += xyz[offset + 1];
								Z += xyz[offset + 2];
							}
						}
						rescaled[i + 0] = X * inv;
						rescaled[i + 1] = Y * inv;
						rescaled[i + 2] = Z * inv;
					}
				}
				return new BitmapXYZ(width / superSample, height / superSample, rescaled);
			} else
				return new BitmapXYZ(width, height, xyz);
		}
		
		private static int read32i(FileStream stream) {
			int i = stream.ReadByte();
			i |= stream.ReadByte() << 8;
			i |= stream.ReadByte() << 16;
			i |= stream.ReadByte() << 24;
			return i;
		}
		
		private static float read32f(FileStream stream) {
			return BitConverter.ToSingle(BitConverter.GetBytes(stream.ReadByte()), 0);
		}
	}
}


